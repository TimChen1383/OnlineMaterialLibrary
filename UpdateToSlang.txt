================================================================================
                    ONLINE MATERIAL LIBRARY - SLANG MIGRATION PLAN
================================================================================

Created: 2026-01-10
Status: Planning Phase

================================================================================
1. EXECUTIVE SUMMARY
================================================================================

This document outlines the migration plan from the current SPIR-V Cross pipeline
to Khronos Slang for shader compilation and cross-platform export.

CURRENT STATE:
  Browser (GLSL) --> Server (glslangValidator) --> SPIR-V --> spirv-cross --> HLSL

  Issues:
  - HLSL output from SPIR-V Cross is machine-generated and hard to read
  - Variable names are mangled (e.g., _42, _temp_0)
  - Code structure is flattened, losing original logic flow
  - Comments and formatting are lost

PROPOSED STATE:
  Browser (Slang) --> Server (Slang Compiler) --> GLSL/HLSL/SPIR-V/Metal/WGSL

  Benefits:
  - Human-readable output in all target languages
  - Maintains variable names and code structure
  - Single source, multiple outputs
  - Modern shader language features
  - Better error messages

================================================================================
2. WHAT IS SLANG?
================================================================================

Slang is a shading language developed by NVIDIA and now part of the Khronos Group.
It is designed as a superset of HLSL with additional features:

KEY FEATURES:
- Cross-platform compilation (GLSL, HLSL, SPIR-V, Metal, WGSL, CUDA, C++)
- Human-readable output (preserves names, structure, and intent)
- Generics and interfaces
- Automatic differentiation (useful for ML/graphics hybrid applications)
- Modular shader programming (import system)
- Backwards compatible with HLSL syntax

SUPPORTED TARGETS:
  1. GLSL (for WebGL/OpenGL)
  2. HLSL (for DirectX)
  3. SPIR-V (for Vulkan/WebGPU)
  4. Metal Shading Language (for Apple platforms)
  5. WGSL (for WebGPU)
  6. CUDA (for NVIDIA compute)
  7. C++ (for CPU fallback)

================================================================================
3. ARCHITECTURE OVERVIEW
================================================================================

3.1 HIGH-LEVEL ARCHITECTURE
--------------------------------------------------------------------------------

  +------------------+       +------------------+       +------------------+
  |     BROWSER      |       |      SERVER      |       |      OUTPUT      |
  |                  |       |                  |       |                  |
  |  React + Three.js|  -->  |  Slang Compiler  |  -->  |  GLSL (WebGL)    |
  |  Monaco Editor   |       |  (slangc)        |       |  HLSL (DX)       |
  |  Slang Source    |       |  Express.js API  |       |  WGSL (WebGPU)   |
  +------------------+       +------------------+       |  Metal (Apple)   |
                                                        |  SPIR-V (Vulkan) |
                                                        +------------------+

3.2 DETAILED DATA FLOW
--------------------------------------------------------------------------------

Phase 1: Editing
  1. User writes Slang code in Monaco editor (browser)
  2. Syntax highlighting for Slang (similar to HLSL)
  3. Real-time preview requires compiled GLSL

Phase 2: Live Preview (for WebGL)
  1. User code sent to server via WebSocket or REST API
  2. Server compiles Slang --> GLSL
  3. GLSL returned to browser
  4. Three.js compiles and renders GLSL
  5. Errors parsed and displayed with line number mapping

Phase 3: Export (for other platforms)
  1. User clicks Export
  2. Server compiles Slang --> target format (HLSL/WGSL/Metal/etc.)
  3. Human-readable code returned to browser
  4. User downloads or copies code

================================================================================
4. SERVER IMPLEMENTATION PLAN
================================================================================

4.1 SLANG COMPILER INSTALLATION
--------------------------------------------------------------------------------

Option A: Pre-built Binaries (Recommended for initial setup)
  - Download from: https://github.com/shader-slang/slang/releases
  - Available for Windows, Linux, macOS
  - Place `slangc` executable in server path

Option B: Docker Container (Recommended for production)
  - Create Dockerfile with Slang compiler
  - Consistent environment across deployments
  - Easy version management

Option C: Build from Source
  - Clone: https://github.com/shader-slang/slang
  - Build using CMake
  - Useful for custom modifications

4.2 SERVER API ENDPOINTS
--------------------------------------------------------------------------------

ENDPOINT: POST /api/compile
  Purpose: Compile Slang to target format

  Request Body:
  {
    "source": "<slang source code>",
    "target": "glsl" | "hlsl" | "spirv" | "wgsl" | "metal",
    "profile": "glsl_450" | "sm_5_0" | "spirv_1_3" | ...,
    "entryPoint": "fragmentMain",
    "stage": "fragment" | "vertex" | "compute"
  }

  Response (Success):
  {
    "success": true,
    "code": "<compiled shader code>",
    "warnings": []
  }

  Response (Error):
  {
    "success": false,
    "errors": [
      { "line": 10, "column": 5, "message": "undefined variable 'foo'" }
    ]
  }

ENDPOINT: GET /api/slang/version
  Purpose: Get Slang compiler version info

ENDPOINT: POST /api/validate
  Purpose: Validate Slang syntax without full compilation

ENDPOINT: GET /api/targets
  Purpose: List available compilation targets

4.3 SERVER CODE STRUCTURE
--------------------------------------------------------------------------------

server/
├── index.cjs                    # Main Express server
├── slang/
│   ├── compiler.js              # Slang compiler wrapper
│   ├── profiles.js              # Target profile configurations
│   ├── wrapper.js               # Slang code wrapper (uniforms, etc.)
│   └── errorParser.js           # Parse Slang error output
├── legacy/
│   └── spirvCross.js            # Keep SPIR-V Cross for backward compat
└── utils/
    └── tempFiles.js             # Temporary file management

4.4 SLANG COMPILER WRAPPER (server/slang/compiler.js)
--------------------------------------------------------------------------------

Key responsibilities:
1. Accept Slang source code
2. Write to temporary file with .slang extension
3. Execute slangc with appropriate flags
4. Parse output/errors
5. Return compiled code or structured errors
6. Clean up temporary files

Example slangc command:
  slangc input.slang -target glsl -profile glsl_450 -entry fragmentMain -o output.glsl

Important slangc flags:
  -target <target>      : Output format (glsl, hlsl, spirv, wgsl, metal)
  -profile <profile>    : Target profile (glsl_450, sm_5_0, etc.)
  -entry <name>         : Entry point function name
  -stage <stage>        : Shader stage (vertex, fragment, compute)
  -o <file>             : Output file path
  -line-directive-mode  : How to emit #line directives
  -matrix-layout-row    : Use row-major matrices (for HLSL compat)

================================================================================
5. FRONTEND IMPLEMENTATION PLAN
================================================================================

5.1 MONACO EDITOR UPDATES
--------------------------------------------------------------------------------

Task: Add Slang syntax highlighting

Slang is syntactically similar to HLSL with some extensions. Create a new
language definition in ShaderEditor.jsx:

1. Register 'slang' language with Monaco
2. Define tokenizer based on HLSL + Slang-specific keywords
3. Add Slang-specific keywords:
   - import, module, interface, extension
   - This, associatedtype, __generic
   - [shader("fragment")], [shader("vertex")]
   - ConstantBuffer, StructuredBuffer, etc.

5.2 SHADER WRAPPER UPDATES (Viewer.jsx)
--------------------------------------------------------------------------------

The current wrapUserCode() functions inject GLSL boilerplate. For Slang:

Option A: Server-Side Wrapping (Recommended)
  - Send raw user code to server
  - Server adds uniforms, entry points, imports
  - Server compiles and returns GLSL for preview
  - Cleaner separation of concerns

Option B: Client-Side Wrapping
  - Wrap user code in Slang boilerplate on client
  - Send wrapped code to server
  - More responsive but duplicates logic

SLANG WRAPPER TEMPLATE:
--------------------------------------------------------------------------------
// Uniforms matching current system
uniform float uTime;
uniform float uTimeDelta;
uniform float uFrame;
uniform float uFrameRate;
uniform float2 uResolution;

// Varyings from vertex shader
struct VSOutput
{
    float4 position : SV_Position;
    float2 uv : TEXCOORD0;
    float3 normal : NORMAL;
    float3 worldPos : TEXCOORD1;
};

// Convenience aliases for user code
static float time;
static float2 resolution;
static float2 uv;
static float3 normal;
static float3 position;

[shader("fragment")]
float4 fragmentMain(VSOutput input) : SV_Target
{
    // Setup convenience variables
    time = uTime;
    resolution = uResolution;
    uv = input.uv;
    normal = input.normal;
    position = input.worldPos;

    // User code variables
    float3 fragColor = float3(0.0);

    // === USER CODE START ===
    ${USER_CODE}
    // === USER CODE END ===

    return float4(fragColor, 1.0);
}
--------------------------------------------------------------------------------

5.3 EXPORT MODAL UPDATES (ExportModal.jsx)
--------------------------------------------------------------------------------

Update tabs to support more export targets:

CURRENT TABS:
  - GLSL
  - HLSL
  - HLSL (Unreal)

NEW TABS:
  - Slang (Source)      : Show original Slang code
  - GLSL                : Compiled for WebGL/OpenGL
  - HLSL                : Compiled for DirectX
  - HLSL (Unreal)       : Post-processed for Unreal Custom Nodes
  - WGSL                : Compiled for WebGPU
  - Metal               : Compiled for Apple platforms
  - SPIR-V (hex/base64) : For Vulkan pipelines

5.4 MANUAL COMPILATION WITH COMPILE BUTTON (RECOMMENDED APPROACH)
--------------------------------------------------------------------------------

Instead of auto-compiling on every keystroke, use a manual "Compile" button.

WHY MANUAL COMPILATION:
  - Reduces server load significantly (only compiles when user is ready)
  - Gives user explicit control over when to compile
  - Avoids wasted compilations during active typing
  - Better user experience for iterative editing
  - Lower server costs for production deployment

UI DESIGN:
  +--------------------------------------------------+
  |  [Compile Button]  [Status: Ready / Compiling]   |
  +--------------------------------------------------+
  |                                                  |
  |   Monaco Editor (Slang code)                     |
  |                                                  |
  +--------------------------------------------------+

COMPILE BUTTON BEHAVIOR:
  1. User writes/edits Slang code in editor
  2. User clicks "Compile" button (or presses Ctrl+Enter / Cmd+Enter)
  3. Button shows loading state ("Compiling...")
  4. Request sent to server for Slang -> GLSL compilation
  5. On success: GLSL returned, preview updates, button shows "Compiled"
  6. On error: Error messages displayed, button shows "Error"
  7. Button resets to "Compile" when user makes new edits

KEYBOARD SHORTCUT:
  - Ctrl+Enter (Windows/Linux) or Cmd+Enter (Mac) to compile
  - Standard shortcut familiar to developers (similar to Jupyter, REPLs)

STATUS INDICATOR:
  - "Ready" - Code has been modified since last compile
  - "Compiling..." - Compilation in progress (with spinner)
  - "Compiled" - Current code is compiled and previewing
  - "Error" - Last compilation failed (click to see errors)

ADDITIONAL OPTIMIZATIONS:

1. Compilation Caching (Server-Side)
   - Hash user code, cache compiled results
   - Return cached GLSL if same code submitted again
   - Reduces redundant compilation

2. Dirty State Tracking (Client-Side)
   - Track if code changed since last compile
   - Visual indicator when preview is "stale"
   - Prompt user to recompile

3. Keyboard-First Workflow
   - Ctrl+Enter: Compile
   - Ctrl+S: Save (if save feature exists)
   - Escape: Cancel ongoing compilation

================================================================================
6. SLANG CODE EXAMPLES
================================================================================

6.1 SIMPLE GRADIENT (Material Library Style)
--------------------------------------------------------------------------------
// User writes this in the editor:
fragColor = float3(uv.x, uv.y, 0.5);
--------------------------------------------------------------------------------

6.2 ANIMATED SHADER (Material Library Style)
--------------------------------------------------------------------------------
// User writes this:
float wave = sin(uv.x * 10.0 + time) * 0.5 + 0.5;
fragColor = float3(wave, uv.y, 1.0 - wave);
--------------------------------------------------------------------------------

6.3 FULL SLANG SHADER (Advanced Mode)
--------------------------------------------------------------------------------
// For users who want full control:

import StandardUniforms;

[shader("fragment")]
float4 fragmentMain(VSOutput input) : SV_Target
{
    float2 uv = input.uv;
    float t = uTime;

    // Raymarching SDF sphere
    float3 ro = float3(0, 0, -3);
    float3 rd = normalize(float3(uv - 0.5, 1.0));

    float d = raymarchSphere(ro, rd);
    float3 color = d < 100.0 ? float3(1, 0.5, 0) : float3(0.1);

    return float4(color, 1.0);
}

float raymarchSphere(float3 ro, float3 rd)
{
    float t = 0.0;
    for(int i = 0; i < 100; i++)
    {
        float3 p = ro + rd * t;
        float d = length(p) - 1.0;
        if(d < 0.001) break;
        t += d;
    }
    return t;
}
--------------------------------------------------------------------------------

================================================================================
7. MIGRATION PHASES
================================================================================

PHASE 1: FOUNDATION (Backend Infrastructure)
--------------------------------------------------------------------------------
Tasks:
[ ] 1.1 Install Slang compiler on development machine
[ ] 1.2 Create Docker container with Slang for deployment
[ ] 1.3 Implement basic /api/compile endpoint
[ ] 1.4 Add error parsing for Slang compiler output
[ ] 1.5 Create Slang code wrapper template
[ ] 1.6 Test compilation pipeline (Slang -> GLSL)
[ ] 1.7 Test all export targets (HLSL, WGSL, Metal)

Deliverable: Working backend that compiles Slang to all targets

PHASE 2: EDITOR INTEGRATION (Frontend Basics)
--------------------------------------------------------------------------------
Tasks:
[ ] 2.1 Add Slang syntax highlighting to Monaco
[ ] 2.2 Create SlangEditor component (or update ShaderEditor)
[ ] 2.3 Add "Compile" button with loading states (Ready/Compiling/Compiled/Error)
[ ] 2.4 Implement Ctrl+Enter keyboard shortcut for compile
[ ] 2.5 Update Viewer.jsx to use compiled GLSL from server
[ ] 2.6 Implement error display with line number mapping
[ ] 2.7 Add dirty state tracking (indicate when preview is stale)
[ ] 2.8 Add status indicator showing compilation state

Deliverable: Editor that writes Slang and compiles on user request

PHASE 3: EXPORT SYSTEM (Multi-Target Export)
--------------------------------------------------------------------------------
Tasks:
[ ] 3.1 Update ExportModal with new target tabs
[ ] 3.2 Implement server calls for each export target
[ ] 3.3 Add Unreal HLSL post-processing
[ ] 3.4 Add syntax highlighting for each output language
[ ] 3.5 Test exported code in target environments
[ ] 3.6 Update download filename extensions

Deliverable: Full export system with readable output for all platforms

PHASE 4: SHADER LIBRARY MIGRATION
--------------------------------------------------------------------------------
Tasks:
[ ] 4.1 Convert existing GLSL shaders to Slang
[ ] 4.2 Update shader loading system for .slang files
[ ] 4.3 Create migration tool for batch conversion
[ ] 4.4 Update Gallery to handle Slang shaders
[ ] 4.5 Validate all converted shaders compile correctly

Deliverable: All library shaders working in new Slang system

PHASE 5: ADVANCED FEATURES
--------------------------------------------------------------------------------
Tasks:
[ ] 5.1 Add ShaderToy compatibility mode (Slang variant)
[ ] 5.2 Add server-side compilation caching (hash-based)
[ ] 5.3 Create Slang module system (importable utilities)
[ ] 5.4 Add auto-completion for Slang in Monaco
[ ] 5.5 Implement code formatting
[ ] 5.6 Add "Auto-compile on save" option (optional feature for power users)

Deliverable: Polished, production-ready Slang authoring system

PHASE 6: CLEANUP & OPTIMIZATION
--------------------------------------------------------------------------------
Tasks:
[ ] 6.1 Remove or archive SPIR-V Cross code
[ ] 6.2 Update documentation and CLAUDE.md
[ ] 6.3 Performance optimization
[ ] 6.4 Security audit of server endpoints
[ ] 6.5 Add rate limiting for public deployment
[ ] 6.6 Final testing across all browsers

Deliverable: Production deployment ready

================================================================================
8. BACKWARD COMPATIBILITY CONSIDERATIONS
================================================================================

8.1 EXISTING GLSL SHADERS
--------------------------------------------------------------------------------
The current shader library contains GLSL code. Options:

Option A: Dual Mode Support
  - Keep both GLSL and Slang editing modes
  - GLSL mode uses current client-side compilation
  - Slang mode uses new server compilation
  - Gradual migration path

Option B: Auto-Migration
  - Slang is largely HLSL-compatible
  - GLSL can be automatically converted with some transformations
  - vec3 -> float3, mix -> lerp, etc.
  - Create migration script

Option C: Manual Rewrite
  - Rewrite each shader in Slang
  - Opportunity to improve/modernize code
  - Most control but most work

RECOMMENDATION: Start with Dual Mode (Option A), then Auto-Migrate (Option B)

8.2 SHADER RULES COMPATIBILITY
--------------------------------------------------------------------------------
Current rules (Material Library, ShaderToy) can be adapted:

Material Library Rule (Slang version):
  - Same convenience variables (time, uv, normal, position)
  - Same output variable (fragColor)
  - Wrapper translates to proper Slang entry point

ShaderToy Rule (Slang version):
  - Create mainImage-compatible wrapper
  - Map iResolution, iTime, etc. to Slang uniforms
  - Detect unsupported features same as current

================================================================================
9. TECHNICAL CONSIDERATIONS
================================================================================

9.1 LATENCY CONSIDERATIONS
--------------------------------------------------------------------------------
Server-side compilation adds latency vs current client-side approach.
However, with manual compile button, this is less critical since:
  - User explicitly triggers compilation (no typing interruption)
  - Compilation happens in background while user waits
  - 500ms-2s compile time is acceptable for manual trigger

Optimization strategies (if needed):
1. Keep server geographically close (CDN/edge deployment)
2. Aggressive caching of compiled shaders (hash-based)
3. Consider WebAssembly Slang compiler in future (if available)
4. Show progress indicator during compilation

9.2 ERROR MESSAGE MAPPING
--------------------------------------------------------------------------------
Slang compiler outputs errors with line numbers. Need to:
1. Parse slangc stderr output
2. Extract line/column information
3. Adjust for wrapper code offset
4. Map back to user code lines
5. Display inline in Monaco editor

9.3 SECURITY
--------------------------------------------------------------------------------
Server executes external compiler with user input. Precautions:
1. Sanitize file paths (no directory traversal)
2. Set compilation timeout (prevent infinite loops)
3. Limit output size
4. Run compiler in sandboxed environment
5. Rate limit API requests
6. Validate input size before processing

9.4 WEBGPU FUTURE-PROOFING
--------------------------------------------------------------------------------
Slang's WGSL output positions the project well for WebGPU:
1. Three.js is adding WebGPU support
2. WGSL is the native WebGPU shading language
3. Slang can target both WebGL (GLSL) and WebGPU (WGSL)
4. Same source code works for both rendering backends

================================================================================
10. FILE CHANGES SUMMARY
================================================================================

NEW FILES TO CREATE:
  server/slang/compiler.js       - Slang compiler wrapper
  server/slang/wrapper.js        - Slang code wrapping utilities
  server/slang/errorParser.js    - Error message parsing
  server/slang/profiles.js       - Target profile configurations
  src/utils/slangApi.js          - Frontend API client for Slang
  src/languages/slang.js         - Monaco Slang language definition
  Dockerfile                     - Docker container with Slang
  Rules/SlangMaterialLibrary.txt - Slang version of Material Library rules
  Rules/SlangShaderToy.txt       - Slang version of ShaderToy rules

FILES TO MODIFY:
  server/index.cjs               - Add new Slang endpoints
  src/components/ShaderEditor.jsx - Add Slang syntax support
  src/components/Viewer.jsx      - Use server-compiled GLSL
  src/components/ExportModal.jsx - Add new export targets
  src/components/Editor.jsx      - Add Slang mode toggle
  package.json                   - Add any new dependencies
  CLAUDE.md                      - Update documentation

FILES TO ARCHIVE (keep for reference):
  src/utils/shaderConverter.js   - Legacy regex converter

================================================================================
11. DEPENDENCIES & TOOLS
================================================================================

SERVER DEPENDENCIES:
  - slangc binary (Slang compiler)
  - Node.js (existing)
  - Express.js (existing)

DOCKER IMAGE:
  Base: node:20-slim
  Add: Slang compiler binaries
  Expose: Port 3001

NPM PACKAGES (no new packages required):
  - All existing packages remain
  - Monaco already supports custom language definitions

================================================================================
12. SUCCESS CRITERIA
================================================================================

The migration is complete when:

[ ] Users can write Slang code in the editor
[ ] Compile button triggers server compilation and updates preview
[ ] Ctrl+Enter keyboard shortcut works for compilation
[ ] Error messages show correct line numbers
[ ] Export produces human-readable code for all targets:
    [ ] GLSL - Variable names preserved
    [ ] HLSL - Variable names preserved, readable structure
    [ ] WGSL - Clean WebGPU-ready code
    [ ] Metal - Native Apple shader code
[ ] Existing shader library works in new system
[ ] ShaderToy compatibility mode works
[ ] Performance is acceptable (< 500ms compile time)
[ ] No regression in current functionality

================================================================================
13. RISKS & MITIGATIONS
================================================================================

RISK: Slang compiler is large/slow to download
  Mitigation: Docker container, CDN distribution, lazy loading

RISK: Slang syntax learning curve for users
  Mitigation: Keep simple mode (auto-wrapped like current GLSL)
              Provide templates and examples
              Slang is very similar to HLSL

RISK: Server downtime affects preview
  Mitigation: Implement fallback to client-side GLSL preview
              Cache last successful compilation
              Health check with graceful degradation

RISK: Breaking changes in Slang compiler updates
  Mitigation: Pin Slang version in Docker
              Test updates before deployment
              Keep compatibility layer

================================================================================
14. RESOURCES & REFERENCES
================================================================================

Slang Official:
  - Repository: https://github.com/shader-slang/slang
  - Documentation: https://shader-slang.com/slang/user-guide/
  - Releases: https://github.com/shader-slang/slang/releases

Slang Language Guide:
  - Getting Started: https://shader-slang.com/slang/user-guide/get-started.html
  - HLSL Compatibility: https://shader-slang.com/slang/user-guide/hlsl-compatibility.html
  - Target Backends: https://shader-slang.com/slang/user-guide/targets.html

Community:
  - Discord: Khronos Group / Slang channels
  - GitHub Issues: For bug reports and feature requests

================================================================================
15. OPEN QUESTIONS
================================================================================

Questions to resolve during implementation:

1. Should users see Slang syntax or maintain GLSL-like syntax with auto-conversion?
   - Option A: Pure Slang (float3, lerp, etc.)
   - Option B: GLSL-like surface syntax with Slang underneath

2. How to handle shader includes/imports?
   - Built-in utility library?
   - User-defined modules?

3. WebGPU preview support?
   - When Three.js WebGPU is stable, should we switch renderer?
   - Dual WebGL/WebGPU support?

4. Paid tier considerations?
   - Server compilation costs resources
   - Rate limiting for free tier?
   - Priority compilation for paid users?

================================================================================
END OF PLAN
================================================================================
