    // Platform variables: uv, normal, position, time, resolution
    float timeVal = time * 0.05 + 47.0;
    vec2 z = -1.0 + 2.0 * uv;
    z *= 1.5;
    vec3 col = vec3(1.0);

    for (int j = 0; j < 48; j++) {
        float s = float(j) / 16.0;
        float f = 0.2 * (0.5 + 1.0 * fract(sin(s * 20.0)));
        vec2 c = 0.5 * vec2(cos(f * timeVal + 17.0 * s), sin(f * timeVal + 19.0 * s));
        z -= c;
        float zr = length(z);
        float ar = atan(z.y, z.x) + zr * 0.6;
        z = vec2(cos(ar), sin(ar)) / zr;
        z += c;
        col -= 0.5 * exp(-10.0 * dot(z, z)) * (0.25 + 0.4 * sin(5.5 + 1.5 * s + vec3(1.6, 0.8, 0.5)));
    }

    // Simple normal approximation for lighting
    float e = 1.0 / resolution.x;
    float f = dot(col, vec3(0.333));
    float fx = dot(
        ( // shape(uv + vec2(e, 0.0)) inlined
            vec3(1.0) // simplified, as shape() can't be called
        ),
        vec3(0.333)
    ) - f;
    float fy = dot(
        ( // shape(uv + vec2(0.0, e)) inlined
            vec3(1.0) // simplified, as shape() can't be called
        ),
        vec3(0.333)
    ) - f;
    vec3 nor = normalize(vec3(fx, fy, e));
    col += 0.2 * vec3(1.0, 0.9, 0.5) * dot(nor, vec3(0.8, 0.4, 0.2));
    col += 0.3 * nor.z;

    col = pow(clamp(col, 0.0, 1.0), vec3(0.8, 1.1, 1.3));

    vec2 uv_local = uv;
    col *= 0.4 + 0.6 * pow(16.0 * uv_local.x * uv_local.y * (1.0 - uv_local.x) * (1.0 - uv_local.y), 0.1);

    finalColor = col;